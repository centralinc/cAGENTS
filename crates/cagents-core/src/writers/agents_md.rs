// write AGENTS.md per target directory (root + nested)

use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

/// Write merged content to AGENTS.md at the specified path
pub fn write_agents_md(output_dir: &Path, content: &str) -> Result<()> {
    let output_path = output_dir.join("AGENTS.md");

    // Prepend auto-update header
    let header = r#"<!--
This file is auto-generated by cAGENTS. Do not edit directly.

To update: run `cagents build`
For file-specific context: run `cagents context <filename>`
-->

"#;

    let full_content = format!("{}{}", header, content);

    fs::write(&output_path, full_content)
        .with_context(|| format!("Failed to write AGENTS.md to {}", output_path.display()))?;

    Ok(())
}

/// Load previously written output locations from tracking file
pub fn load_output_tracking() -> Result<Vec<PathBuf>> {
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    if !tracking_file.exists() {
        return Ok(Vec::new());
    }

    let content = fs::read_to_string(&tracking_file)?;
    let paths: Vec<PathBuf> = content
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(PathBuf::from)
        .collect();

    Ok(paths)
}

/// Save output locations to tracking file
pub fn save_output_tracking(paths: &[PathBuf]) -> Result<()> {
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    let content = paths
        .iter()
        .map(|p| p.display().to_string())
        .collect::<Vec<_>>()
        .join("\n");

    fs::write(&tracking_file, content + "\n")?;

    Ok(())
}

/// Clean up old AGENTS.md files that are no longer generated
pub fn cleanup_old_outputs(current_outputs: &[PathBuf]) -> Result<usize> {
    let previous_outputs = load_output_tracking()?;
    let mut cleaned_count = 0;

    for old_path in previous_outputs {
        // Skip if this path is still in current outputs
        if current_outputs.contains(&old_path) {
            continue;
        }

        // Remove the old AGENTS.md file
        let agents_path = old_path.join("AGENTS.md");
        if agents_path.exists() {
            if let Err(e) = fs::remove_file(&agents_path) {
                eprintln!("  Warning: Could not remove old {}: {}", agents_path.display(), e);
            } else {
                cleaned_count += 1;
            }
        }
    }

    Ok(cleaned_count)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use tempfile::TempDir;

    #[test]
    fn test_write_agents_md() {
        let temp_dir = TempDir::new().unwrap();
        let content = "# Test Content\n\nThis is a test.";

        write_agents_md(temp_dir.path(), content).unwrap();

        let written = fs::read_to_string(temp_dir.path().join("AGENTS.md")).unwrap();

        // Should include auto-update header
        assert!(written.contains("cagents build"));
        assert!(written.contains("cagents context"));
        // Should include original content
        assert!(written.contains("# Test Content"));
        assert!(written.contains("This is a test."));
    }

    #[test]
    #[serial]
    fn test_cleanup_removes_old_outputs() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // Create old AGENTS.md files
        fs::create_dir_all("src").unwrap();
        fs::create_dir_all("tests").unwrap();
        fs::write("src/AGENTS.md", "# Old Src").unwrap();
        fs::write("tests/AGENTS.md", "# Old Tests").unwrap();
        fs::write("AGENTS.md", "# Old Root").unwrap();

        // Save tracking of old locations
        let old_paths = vec![
            PathBuf::from("."),
            PathBuf::from("src"),
            PathBuf::from("tests"),
        ];
        save_output_tracking(&old_paths).unwrap();

        // New build only generates in root
        let new_paths = vec![PathBuf::from(".")];
        let cleaned = cleanup_old_outputs(&new_paths).unwrap();

        // Restore directory
        env::set_current_dir(original).unwrap();

        // Should have cleaned 2 files
        assert_eq!(cleaned, 2);
        assert!(!tmp.path().join("src/AGENTS.md").exists());
        assert!(!tmp.path().join("tests/AGENTS.md").exists());
        assert!(tmp.path().join("AGENTS.md").exists()); // Still exists
    }

    #[test]
    #[serial]
    fn test_cleanup_no_previous_tracking() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // No previous tracking file
        let new_paths = vec![PathBuf::from(".")];
        let cleaned = cleanup_old_outputs(&new_paths).unwrap();

        env::set_current_dir(original).unwrap();

        // Should clean nothing
        assert_eq!(cleaned, 0);
    }

    #[test]
    #[serial]
    fn test_save_and_load_tracking() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // Save paths
        let paths = vec![
            PathBuf::from("."),
            PathBuf::from("src"),
            PathBuf::from("tests/integration"),
        ];
        save_output_tracking(&paths).unwrap();

        // Load back
        let loaded = load_output_tracking().unwrap();

        env::set_current_dir(original).unwrap();

        assert_eq!(loaded.len(), 3);
        assert!(loaded.contains(&PathBuf::from(".")));
        assert!(loaded.contains(&PathBuf::from("src")));
        assert!(loaded.contains(&PathBuf::from("tests/integration")));
    }
}
