// write AGENTS.md per target directory (root + nested)

use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};

/// Write merged content to AGENTS.md at the specified path
pub fn write_agents_md(output_dir: &Path, content: &str) -> Result<()> {
    let output_path = output_dir.join("AGENTS.md");

    // Prepend auto-update header
    let header = r#"<!--
This file is auto-generated by cAGENTS. Do not edit directly.

To update: run `cagents build`
For file-specific context: run `cagents context <filename>`
-->

"#;

    // Append cAGENTS best practices footer
    let footer = r#"

---

## Working with cAGENTS

This file was generated by cAGENTS. To work efficiently with this codebase:

1. **Run once at start of session**: `cagents build` ensures all agent rules are up-to-date
2. **Get file-specific context**: `cagents context <filename>` retrieves all relevant rules for a specific file - more efficient than reading this entire file
3. **Best practice**: Re-run `cagents build` when context seems stale or after pulling changes

Learn more: https://github.com/centralinc/cagents
"#;

    let full_content = format!("{}{}{}", header, content, footer);

    fs::write(&output_path, full_content)
        .with_context(|| format!("Failed to write AGENTS.md to {}", output_path.display()))?;

    Ok(())
}

/// Tracking information for cleanup
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct OutputTracking {
    pub directories: Vec<PathBuf>,
    pub targets: Vec<String>,
}

/// Load previously written output tracking from cache file
pub fn load_output_tracking() -> Result<Vec<PathBuf>> {
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    if !tracking_file.exists() {
        return Ok(Vec::new());
    }

    let content = fs::read_to_string(&tracking_file)?;

    // Try to parse as JSON first (new format)
    if let Ok(tracking) = serde_json::from_str::<OutputTracking>(&content) {
        return Ok(tracking.directories);
    }

    // Fallback to old format (line-separated paths)
    let paths: Vec<PathBuf> = content
        .lines()
        .filter(|line| !line.trim().is_empty())
        .map(PathBuf::from)
        .collect();

    Ok(paths)
}

/// Load full tracking information (directories + targets)
pub fn load_full_tracking() -> Result<Option<OutputTracking>> {
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    if !tracking_file.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&tracking_file)?;

    // Try to parse as JSON (new format)
    if let Ok(tracking) = serde_json::from_str::<OutputTracking>(&content) {
        return Ok(Some(tracking));
    }

    // Fallback to old format - only has directories, no targets info
    Ok(None)
}

/// Save output tracking (directories and targets)
pub fn save_output_tracking(paths: &[PathBuf]) -> Result<()> {
    // Legacy function - only saves directories
    // Use save_full_tracking for new behavior
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    let content = paths
        .iter()
        .map(|p| p.display().to_string())
        .collect::<Vec<_>>()
        .join("\n");

    fs::write(&tracking_file, content + "\n")?;

    Ok(())
}

/// Save full tracking information (directories + targets)
pub fn save_full_tracking(directories: &[PathBuf], targets: &[String]) -> Result<()> {
    let tracking_file = PathBuf::from(".cAGENTS/.output-cache");

    let tracking = OutputTracking {
        directories: directories.to_vec(),
        targets: targets.to_vec(),
    };

    let json = serde_json::to_string_pretty(&tracking)?;
    fs::write(&tracking_file, json)?;

    Ok(())
}

/// Clean up old AGENTS.md files that are no longer generated
pub fn cleanup_old_outputs(current_outputs: &[PathBuf]) -> Result<usize> {
    let previous_outputs = load_output_tracking()?;
    let mut cleaned_count = 0;

    for old_path in previous_outputs {
        // Skip if this path is still in current outputs
        if current_outputs.contains(&old_path) {
            continue;
        }

        // Remove the old AGENTS.md file
        let agents_path = old_path.join("AGENTS.md");
        if agents_path.exists() {
            if let Err(e) = fs::remove_file(&agents_path) {
                eprintln!("  Warning: Could not remove old {}: {}", agents_path.display(), e);
            } else {
                cleaned_count += 1;
            }
        }
    }

    Ok(cleaned_count)
}

/// Clean up output files for targets that are no longer in config
pub fn cleanup_old_target_files(current_targets: &[String], output_root: &Path) -> Result<usize> {
    let previous_tracking = load_full_tracking()?;
    let mut cleaned_count = 0;

    // If no previous tracking, nothing to clean up
    let Some(prev) = previous_tracking else {
        return Ok(0);
    };

    // Find targets that were removed
    let removed_targets: Vec<&String> = prev.targets.iter()
        .filter(|t| !current_targets.contains(t))
        .collect();

    if removed_targets.is_empty() {
        return Ok(0);
    }

    // For each removed target, clean up its files
    for target in removed_targets {
        let file_path = match target.as_str() {
            "agents-md" => output_root.join("AGENTS.md"),
            "claude-md" => output_root.join("CLAUDE.md"),
            "cursorrules" => output_root.join(".cursorrules"),
            _ => continue,
        };

        if file_path.exists() {
            if let Err(e) = fs::remove_file(&file_path) {
                eprintln!("  Warning: Could not remove old {}: {}", file_path.display(), e);
            } else {
                cleaned_count += 1;
            }
        }
    }

    Ok(cleaned_count)
}

#[cfg(test)]
mod tests {
    use super::*;
    use serial_test::serial;
    use tempfile::TempDir;

    #[test]
    fn test_write_agents_md() {
        let temp_dir = TempDir::new().unwrap();
        let content = "# Test Content\n\nThis is a test.";

        write_agents_md(temp_dir.path(), content).unwrap();

        let written = fs::read_to_string(temp_dir.path().join("AGENTS.md")).unwrap();

        // Should include auto-update header
        assert!(written.contains("cagents build"));
        assert!(written.contains("cagents context"));
        // Should include original content
        assert!(written.contains("# Test Content"));
        assert!(written.contains("This is a test."));
    }

    #[test]
    #[serial]
    fn test_cleanup_removes_old_outputs() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // Create old AGENTS.md files
        fs::create_dir_all("src").unwrap();
        fs::create_dir_all("tests").unwrap();
        fs::write("src/AGENTS.md", "# Old Src").unwrap();
        fs::write("tests/AGENTS.md", "# Old Tests").unwrap();
        fs::write("AGENTS.md", "# Old Root").unwrap();

        // Save tracking of old locations
        let old_paths = vec![
            PathBuf::from("."),
            PathBuf::from("src"),
            PathBuf::from("tests"),
        ];
        save_output_tracking(&old_paths).unwrap();

        // New build only generates in root
        let new_paths = vec![PathBuf::from(".")];
        let cleaned = cleanup_old_outputs(&new_paths).unwrap();

        // Restore directory
        env::set_current_dir(original).unwrap();

        // Should have cleaned 2 files
        assert_eq!(cleaned, 2);
        assert!(!tmp.path().join("src/AGENTS.md").exists());
        assert!(!tmp.path().join("tests/AGENTS.md").exists());
        assert!(tmp.path().join("AGENTS.md").exists()); // Still exists
    }

    #[test]
    #[serial]
    fn test_cleanup_no_previous_tracking() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // No previous tracking file
        let new_paths = vec![PathBuf::from(".")];
        let cleaned = cleanup_old_outputs(&new_paths).unwrap();

        env::set_current_dir(original).unwrap();

        // Should clean nothing
        assert_eq!(cleaned, 0);
    }

    #[test]
    #[serial]
    fn test_save_and_load_tracking() {
        use std::env;

        let tmp = TempDir::new().unwrap();
        let original = env::current_dir().unwrap();
        env::set_current_dir(tmp.path()).unwrap();

        // Create .cAGENTS directory
        fs::create_dir_all(".cAGENTS").unwrap();

        // Save paths
        let paths = vec![
            PathBuf::from("."),
            PathBuf::from("src"),
            PathBuf::from("tests/integration"),
        ];
        save_output_tracking(&paths).unwrap();

        // Load back
        let loaded = load_output_tracking().unwrap();

        env::set_current_dir(original).unwrap();

        assert_eq!(loaded.len(), 3);
        assert!(loaded.contains(&PathBuf::from(".")));
        assert!(loaded.contains(&PathBuf::from("src")));
        assert!(loaded.contains(&PathBuf::from("tests/integration")));
    }
}
